---
title: 使用信号流做服务器返回解析初步处理
date: 2018-12-27 22:22:00
tags: 
    - Android
    - 总结
---
之前为项目网络请求初步解析构建过方案,使用过了一个项目,发现有很多缺点
- 不能接着转发信号,例如flapMap之类的
- 定死了Observer,无法根据实际情况选择
- 多人协助中,很难让所有人统一发送和接收

归根结底,这是一种利用Rxjava写传统java的方案,从设计上来说就有根本问题.
在对Reactive有了进一步学习后,我发现关键是不该由Observer来处理信号,而是该从信号到处理后信号的转变,再发出来.

其实RxJava提供ObservableTransformer和Compose,利用这一点可以很方便的实现复杂信号处理.实现后调用代码如下:

```java
    Observable<BaseJsonResultBean> observable = UploadHelper.getInstance().uploadFile("url")
                .compose(NetWorkComposeHelper.handlerBaseJsonResult())
                .flatMap((Function<UploadPicBean, Observable<? extends BaseJsonResultBean<UploadPicBean>>>) uploadPicBean -> {
                //这里已经是处理好code Message的结果.失败不会走这里
                    return RetrofitFactory.getInstance().getApiService().upLoad(UploadPicBean.getUrl());
                })
                .compose(NetWorkComposeHelper.handlerBaseJsonResult());
                
        //可以根据情况选Consumer或者Observer
        observable.subscribe(new Consumer<BaseJsonResultBean>() {
            @Override
            public void accept(BaseJsonResultBean baseResultBean) throws Exception {

            }
        });
```

可以看出:
- 调用者可以清楚的认知到Compose内容(handlerBaseJsonResult)
- 可以根据情况使用各种Observer
- 可以继续对信号量进行处理,转换
- 在MVVM,MVP模式中,可以有效分离业务逻辑和页面逻辑

handlerBaseJsonResult做了code的初步处理,错误信息抛出,token失败重试的操作.

```java
   /**
     * 对服务返回的Json,根据Code判断状态,只返回Data部分
     * @param <T>
     * @return
     */
    public static <T> ObservableTransformer<BaseResultBean<T>, T> handlerBaseJsonResult() {
        return new ObservableTransformer<BaseResultBean<T>, T>() {
            @Override
            public ObservableSource<T> apply(Observable<BaseResultBean<T>> upstream) {
                return upstream.flatMap(new Function<BaseResultBean<T>, ObservableSource<T>>() {
                    @Override
                    public ObservableSource<T> apply(BaseResultBean<T> tBaseResultBean) throws Exception {
                        if (tBaseResultBean == null) {
                            return Observable.error(new Throwable("服务器返回错误"));
                        }
                        if (tBaseResultBean.getCode() == TokenRefresher.CODE_TOKEN_NEEDRETRY) {
                            //Token过期,重新刷新Token
                            return Observable.error(new Throwable(TokenRefresher.ERROR_TOKEN_NEEDRETRY));
                        }
                        if (tBaseResultBean.getCode() == TokenRefresher.CODE_TOKEN_OCCUPYED) {
                            //todo Token冲突,直接回到登录页并提示用户被踢
                            return Observable.error(new Throwable(TokenRefresher.ERROR_TOKEN_OCCUPYED));
                        }
                        if (tBaseResultBean.getCode() != 0) {
                            return Observable.error(new Throwable(tBaseResultBean.getMessage()));
                        }
                        return Observable.just(tBaseResultBean.getResult());
                    }
                }).retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {
                //只重试一次
                    private int mRetryCount = 0;

                    @Override
                    public ObservableSource<?> apply(Observable<Throwable> throwableObservable) throws Exception {
                        return throwableObservable.flatMap((Function<Throwable, ObservableSource<?>>) throwable -> {
                            if (mRetryCount > 0) {
                                return Observable.error(new Throwable(TokenRefresher.ERROR_TOKEN_RETRYFAILD));
                            } else if (TokenRefresher.ERROR_TOKEN_NEEDRETRY.equalsIgnoreCase(throwable.getMessage())) {
                                mRetryCount++;
                                //多个请求失效,只刷一次Token
                                return TokenRefresher.getInstance().getNetTokenLocked();
                            } else {
                                return Observable.error(throwable);
                            }
                        });
                    }
                //io网络请求是必须的
                //也可以为了方便加上observeOn,但observeOn不一定是Main,也要考虑这种情况
                }).subscribeOn(Schedulers.io());
            }
        };
    }
```